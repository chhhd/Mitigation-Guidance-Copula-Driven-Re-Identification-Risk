<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>항목별 전략 추천</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Pretendard Variable (임계값 분석과 동일 폰트) -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.css"
    />
    <style>
      :root{
        --font-ui: 'Pretendard Variable', Pretendard, -apple-system, system-ui,
                   'Segoe UI', Roboto, 'Noto Sans KR', 'Apple SD Gothic Neo',
                   'Malgun Gothic', 'Helvetica Neue', Arial, sans-serif;
      }
      body{
        background:#121212;
        color:#e5e7eb;
        font-family: var(--font-ui);
      }
      .section-title{
        font-weight: 900;
        letter-spacing: -0.02em;
        color:#1d4ed8;
        text-shadow:0 1px 0 rgba(255,255,255,.6);
      }
      .card{ border-radius:1.25rem; background:rgba(255,255,255,.9); backdrop-filter: blur(6px); box-shadow:0 10px 30px rgba(15,23,42,.08); border:1px solid rgba(2,6,23,.06); color:#0f172a; }
      .tbl{width:100%; border-collapse:separate; border-spacing:0 .5rem}
      .tbl th{font-size:.9rem; color:#94a3b8; text-align:left; padding:.5rem .75rem}
      .tbl td{background:#f8fafc; padding:.75rem .75rem}
      .tbl tr td:first-child{border-radius:.75rem 0 0 .75rem}
      .tbl tr td:last-child{border-radius:0 .75rem .75rem 0}
      .dz{ border:2px dashed #e5e7eb; border-radius:1rem; padding:1.25rem; background:#f8fafc; transition: box-shadow .2s, background .2s, border-color .2s; cursor:pointer; display:flex; align-items:center; justify-content:center; }
      .dz:hover{ background:#f1f5f9; box-shadow:0 6px 14px rgba(2,6,23,.06); }
      .dz-hl{ outline:2px solid #6366f1; background:rgba(99,102,241,.06) }
      .dz-pill{ border-radius:9999px; background:#eef2ff; color:#3730a3; height:42px; display:inline-flex; align-items:center; justify-content:center; padding:0 16px; font-weight:700; text-align:center; }
      .filter-wrap{ display:flex; gap:.5rem; flex-wrap:wrap; margin-bottom:.5rem }
      .filter-btn{ padding:.4rem .8rem; border-radius:9999px; background:#f1f5f9; font-weight:700; color:#374151; box-shadow: inset 0 1px 0 rgba(2,6,23,.04); }
      .filter-btn:hover{ background:#e2e8f0; }
      .filter-btn.active{ background:#2563eb; color:#fff; }
    </style>
  </head>
  <body>
    <section class="py-10">
      <div class="max-w-6xl mx-auto px-4">
        <h2 class="section-title text-3xl md:text-4xl mb-4" style="color:#fff;">특성별 전략 추천</h2>
        <div class="card p-5 mb-5">
          <h3 class="mb-2">일괄 업로드 <span class="uppercase text-slate-500 text-xs">zip</span></h3>
          <label id="zipZone" class="dz block text-center">
            <input id="zipInput" type="file" accept=".zip" class="sr-only" />
            <div class="dz-pill inline-block">file.zip</div>
          </label>
          <div id="zipStatus" class="mt-3 text-xs text-slate-700"></div>
        </div>
        <div class="card p-5">
          <div id="strategyFilters" class="filter-wrap mb-3">
            <button class="filter-btn" data-strat="Density-based">Density-based</button>
            <button class="filter-btn" data-strat="Log binning">Log binning</button>
            <button class="filter-btn" data-strat="KMeans">KMeans</button>
            <button class="filter-btn" data-strat="Decision Tree">Decision Tree</button>
          </div>
          <div class="overflow-x-auto">
            <table class="tbl min-w-[900px]">
              <thead id="head">
                <tr>
                  <th>Feature</th><th>Strategy</th><th>Cut Pctl</th><th>Threshold</th><th>F1</th><th>Recall</th><th>FPR</th><th>MAE</th><th>Importance</th><th>Integrated Risk</th>
                </tr>
              </thead>
              <tbody id="body"></tbody>
            </table>
          </div>
          <p id="status" class="text-sm text-slate-600 mt-3"></p>
        </div>
      </div>
    </section>

    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="zip-bridge.js"></script>
    <script>
      async function autoLoadZipFromBridge(){
        if(!window.ZipBridge) return;
        try{
          const stored = await ZipBridge.load();
          if(!stored?.blob) return;
          const input = document.getElementById('zipInput');
          if(!input || input.files?.length) return;
          const file = new File([stored.blob], stored.name || 'bundle.zip', {
            type:'application/zip',
            lastModified: stored.lastModified || Date.now()
          });
          const dt = new DataTransfer();
          dt.items.add(file);
          input.files = dt.files;
          input.dispatchEvent(new Event('change'));
        }catch(err){
          console.warn('ZIP 자동 로드 실패', err);
        }
      }
      // ---------- utils ----------
      function toNum(v){ if(v==null) return NaN; const s=String(v).trim().replace(/\s+/g,'').replace(/,/g,''); const n=+s; return Number.isFinite(n)? n : NaN; }
      function normKey(s){ return String(s||'').toLowerCase().replace(/[\s_]+/g,''); }
      function parseCSV(text){
        const first=(text.split(/\r?\n/)[0]||''); const cand=[',',';','\t']; let d=',',best=-1; for(const c of cand){ const k=(first.match(new RegExp('\\'+c,'g'))||[]).length; if(k>best){best=k; d=c;} }
        const rows=[]; let cur='',row=[],inQ=false; const pushCell=()=>{row.push(cur);cur='';}; const pushRow=()=>{rows.push(row);row=[];};
        for(let i=0;i<text.length;i++){
          const ch=text[i];
          if(inQ){ if(ch==='"'&&text[i+1]==='"'){cur+='"';i++;continue;} if(ch==='"'){inQ=false;continue;} cur+=ch; continue; }
          if(ch==='"'){inQ=true;continue;} if(ch===d){pushCell();continue;} if(ch==='\n'){pushCell();pushRow();continue;} if(ch==='\r'){continue;} cur+=ch;
        }
        pushCell(); if(row.length>1||row[0]!=='' ) pushRow(); if(rows.length===0) return {header:[],rows:[]};
        const header=rows[0].map(h=> String(h||'').trim());
        const data=rows.slice(1).filter(r=> r.some(x=> String(x).trim()!=='') ).map(r=>{ const o={}; header.forEach((h,i)=> o[h]=(r[i]??'').trim()); return o; });
        return {header, rows:data};
      }
      async function fetchText(url){ try{ const r=await fetch(url,{cache:'no-store'}); if(!r.ok) return null; return await r.text(); }catch{ return null; } }
      async function firstExisting(paths){ for(const p of paths){ const t=await fetchText(p); if(t){ return t; } } return null; }

      // ---------- math helpers ----------
      function erf(x){ const sign=x<0?-1:1; x=Math.abs(x); const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911; const t=1/(1+p*x); const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x); return sign*y; }
      function cdf(z){ return 0.5*(1+erf(z/Math.SQRT2)); }
      function intersections(m1,s1,m2,s2){ if(!isFinite(m1)||!isFinite(s1)||!isFinite(m2)||!isFinite(s2)||s1<=0||s2<=0) return []; const a=(1/(2*s2*s2))-(1/(2*s1*s1)); const b=(-m2/(s2*s2))+(m1/(s1*s1)); const c=(m2*m2/(2*s2*s2))-(m1*m1/(2*s1*s1))-Math.log(s2/s1); if(Math.abs(a)<1e-12){ if(Math.abs(b)<1e-12) return []; return [-c/b]; } const disc=b*b-4*a*c; if(disc<0) return []; const s=Math.sqrt(Math.max(0,disc)); return [(-b-s)/(2*a),(-b+s)/(2*a)]; }
      function chooseThreshold(m1,s1,m2,s2){ const xs=intersections(m1,s1,m2,s2); if(xs.length){ const mid=(m1+m2)/2; let best=xs[0],bd=Math.abs(xs[0]-mid); for(const x of xs){ const d=Math.abs(x-mid); if(d<bd){best=x;bd=d;} } return best; } return (m1+m2)/2; }

      // ---------- parsing helpers ----------
      function mapImportance(parsed){
        const h=parsed.header.map(h=>({raw:h,key:normKey(h)}));
        const feat=(h.find(x=>['feature','name'].includes(x.key))||{}).raw || parsed.header[0];
        const imp=(h.find(x=>['importance','weight','score'].includes(x.key))||{}).raw || parsed.header[1];
        const m=new Map(); parsed.rows.forEach(r=>{ const f=(r[feat]||'').trim(); const v=toNum(r[imp]); if(f && Number.isFinite(v)) m.set(f,v); }); return m;
      }
      function mapRisk(parsed){
        const h=parsed.header.map(h=>({raw:h,key:normKey(h)}));
        const feat=(h.find(x=>['feature','name'].includes(x.key))||{}).raw || parsed.header[0];
        const risk=(h.find(x=>['risk','risk_score','integratedrisk','integrated_risk','integratedriskscore'].includes(x.key))||{}).raw || parsed.header.at(-1);
        const m=new Map(); parsed.rows.forEach(r=>{ const f=(r[feat]||'').trim(); const v=toNum(r[risk]); if(f && Number.isFinite(v)) m.set(f,v); }); return m;
      }
      function summaryToMap(parsed){
        const m=new Map();
        parsed.rows.forEach(r=>{
          const kv=new Map(Object.entries(r).map(([k,v])=> [normKey(k),v]));
          const f=(r['feature']||r['Feature']||kv.get('feature')||'').trim();
          if(!f) return;
          const get=(keys)=>{ for(const kk of keys){ if(kv.has(kk)) return toNum(kv.get(kk)); } return NaN; };
          m.set(f, {
            feature:f,
            count:get(['count','n']), mean:get(['mean']), std:get(['std','stdev','stddev']),
            min:get(['min']), q25:get(['25','25%']), q50:get(['50','50%','median']), q75:get(['75','75%']), max:get(['max'])
          });
        });
        return m;
      }
      function parseStrategyByAligning(parsedStrategy, originalSummary){
        if(!parsedStrategy?.rows?.length) return new Map();
        const h=parsedStrategy.header.map(h=>({raw:h,key:normKey(h)}));
        const featCol=(h.find(x=> ['feature','name','featurename'].includes(x.key))||{}).raw;
        const recCol=(h.find(x=> ['recommended_strategy','recommendedstrategy','strategy','beststrategy','best_strategy'].includes(x.key))||{}).raw;
        const out=new Map();
        if(recCol){
          if(featCol){ parsedStrategy.rows.forEach(r=>{ const f=(r[featCol]||'').trim(); const s=(r[recCol]||'').trim(); if(f && s) out.set(f, s); }); return out; }
          const feats=Array.from(originalSummary.keys());
          parsedStrategy.rows.forEach((r,i)=>{ const f=feats[i]; if(!f) return; const s=(r[recCol]||'').trim(); if(s) out.set(f, s); });
          return out;
        }
        return out;
      }
      function computeMetrics(orig, pseudo){
        const m1=orig.mean, s1=Math.max(orig.std||0,1e-6), n1=Math.max(1,Math.round(orig.count||0));
        const m2=pseudo.mean, s2=Math.max(pseudo.std||0,1e-6), n2=Math.max(1,Math.round(pseudo.count||0));
        const thr=chooseThreshold(m1,s1,m2,s2);
        const posGreater=(m2>=m1);
        const z1=(thr-m1)/s1, z2=(thr-m2)/s2;
        const FPR= posGreater ? (1-cdf(z1)) : cdf(z1);
        const Recall= posGreater ? (1-cdf(z2)) : cdf(z2);
        const pos=n2/(n1+n2), neg=1-pos; const TP=pos*Recall, FP=neg*FPR;
        const Prec = TP>0 ? TP/(TP+FP) : 0; const F1=(Prec+Recall)>0 ? 2*Prec*Recall/(Prec+Recall) : 0;
        const pct = Math.round(100 * cdf((thr - m1)/s1));
        const diffs=[]; if(isFinite(orig.q25)&&isFinite(pseudo.q25)) diffs.push(Math.abs(orig.q25-pseudo.q25)); if(isFinite(orig.q50)&&isFinite(pseudo.q50)) diffs.push(Math.abs(orig.q50-pseudo.q50)); if(isFinite(orig.q75)&&isFinite(pseudo.q75)) diffs.push(Math.abs(orig.q75-pseudo.q75));
        const MAE = diffs.length ? diffs.reduce((a,b)=>a+b,0)/diffs.length : Math.abs(m1-m2);
        const sp=Math.sqrt(((n1-1)*s1*s1 + (n2-1)*s2*s2) / Math.max(1,(n1+n2-2))); const effect=sp>0? Math.abs(m2-m1)/sp : Math.abs(m2-m1);
        return {thr,pct,F1,Recall,FPR,MAE,effect};
      }
      function pickStrategy(effect, orig, pseudo, fallback){
        if(fallback) return fallback;
        const tail1=(isFinite(orig.q50)&&isFinite(orig.q25)) ? Math.abs((orig.max-orig.q75)/Math.max(1e-6,(orig.q50-orig.q25))) : 0;
        const tail2=(isFinite(pseudo.q50)&&isFinite(pseudo.q25)) ? Math.abs((pseudo.max-pseudo.q75)/Math.max(1e-6,(pseudo.q50-pseudo.q25))) : 0;
        if(Math.max(tail1,tail2)>8) return 'Log binning';
        if(effect>1.2) return 'Decision Tree';
        if(effect>0.6) return 'KMeans';
        return 'Log binning';
      }

      let __zipSources = null;
      let __allRows=[]; let __currentFilter=null;
      function renderRows(rows){
        const tbody=document.getElementById('body'); tbody.innerHTML='';
        const fmt=(v, d=3)=> Number.isFinite(v)? (+v).toFixed(d) : '-';
        rows.forEach(r=>{
          const tr=document.createElement('tr');
          tr.innerHTML=`<td class='font-semibold'>${r.feature}</td>
                        <td>${r.strategy||'-'}</td>
                        <td>${Number.isFinite(r.pct)? 'P'+r.pct: '-'}</td>
                        <td>${Number.isFinite(r.thr)? (+r.thr).toFixed(2): '-'}</td>
                        <td>${fmt(r.F1,3)}</td>
                        <td>${Number.isFinite(r.Recall)? (r.Recall*100).toFixed(1)+'%':'-'}</td>
                        <td>${Number.isFinite(r.FPR)? (r.FPR*100).toFixed(1)+'%':'-'}</td>
                        <td>${fmt(r.MAE,3)}</td>
                        <td>${fmt(r.importance,3)}</td>
                        <td>${Number.isFinite(r.risk)? (+r.risk).toFixed(3): '-'}</td>`;
          tbody.appendChild(tr);
        });
        const status=document.getElementById('status');
        const total=__allRows.length, n=rows.length;
        const pref = __currentFilter? `${__currentFilter} · ${n}/${total}` : `${total}`;
        if(status.dataset.base){ status.textContent = `${status.dataset.base} · showing ${pref}`; }
      }

      async function loadAndRender(){
        const txtOrig   = (__zipSources && __zipSources.orig)   || await firstExisting(['file/feature_summary_original.csv','file/feature_summary.csv']);
        const txtPseudo = (__zipSources && __zipSources.pseudo) || await firstExisting(['file/feature_summary_pseudo.csv']);
        const txtStrat  = (__zipSources && __zipSources.strat)  || await firstExisting(['file/feature_statistics_with_strategy.csv']);
        const txtImp    = (__zipSources && __zipSources.imp)    || await firstExisting(['file/xai_feature_importance.csv','file/feature_importances.csv']);
        const txtRisk   = (__zipSources && __zipSources.risk)   || await firstExisting(['file/integrated_risk_score.csv','file/integrated_risk.csv']);
        const status=document.getElementById('status');
        status.textContent='Loading files...';
        if(!txtOrig || !txtPseudo){ status.textContent='Missing summary CSVs (feature_summary_*)'; return; }
        const pOrig=parseCSV(txtOrig); const pPseudo=parseCSV(txtPseudo);
        const mapOrig=summaryToMap(pOrig); const mapPseudo=summaryToMap(pPseudo);
        const featList=Array.from(mapOrig.keys());
        const stratMap = parseStrategyByAligning(txtStrat? parseCSV(txtStrat): null, mapOrig);
        const impMap   = txtImp? mapImportance(parseCSV(txtImp)) : new Map();
        const riskMap  = txtRisk? mapRisk(parseCSV(txtRisk)) : new Map();
        const rows=[];
        featList.forEach(f=>{
          const o=mapOrig.get(f); const p=mapPseudo.get(f); if(!o||!p) return;
          const m=computeMetrics(o,p);
          const imp = Number.isFinite(impMap.get(f))? impMap.get(f) : m.effect;
          const fallback = stratMap.get(f) || null;
          const strategy= pickStrategy(m.effect, o, p, fallback);
          rows.push({ feature:f, strategy, pct:m.pct, thr:m.thr, F1:m.F1, Recall:m.Recall, FPR:m.FPR, MAE:m.MAE, importance:imp, risk:riskMap.get(f) });
        });
        rows.sort((a,b)=>{ const ar = Number.isFinite(a.risk)? a.risk : -Infinity; const br = Number.isFinite(b.risk)? b.risk : -Infinity; if(br!==ar) return br-ar; const ai=Number.isFinite(a.importance)?a.importance:-Infinity; const bi=Number.isFinite(b.importance)?b.importance:-Infinity; return bi-ai; });
        __allRows = rows;
        status.dataset.base = `features: ${rows.length}, sources: `+
          [txtOrig&&'orig', txtPseudo&&'pseudo', txtStrat&&'strat', txtImp&&'imp', txtRisk&&'risk'].filter(Boolean).join(', ');
        const filtered = __currentFilter ? __allRows.filter(r=> (r.strategy||'').toLowerCase()===__currentFilter.toLowerCase()) : __allRows;
        renderRows(filtered);
      }
      window.addEventListener('load', loadAndRender);

      // strategy filter buttons
      (function(){
        const bar=document.getElementById('strategyFilters'); if(!bar) return;
        const btns=bar.querySelectorAll('.filter-btn');
        btns.forEach(btn=>{
          btn.addEventListener('click', ()=>{
            const strat=btn.dataset.strat;
            if(__currentFilter===strat){ __currentFilter=null; btns.forEach(b=>b.classList.remove('active')); }
            else { __currentFilter=strat; btns.forEach(b=>b.classList.toggle('active', b===btn)); }
            const rows = __currentFilter ? __allRows.filter(r=> (r.strategy||'').toLowerCase()===__currentFilter.toLowerCase()) : __allRows;
            renderRows(rows);
          });
        });
      })();

      async function handleZipUpload(file){
        const status = document.getElementById('zipStatus');
        try{
          if(!window.JSZip){ status.textContent='JSZip not loaded'; return; }
          const zip = await JSZip.loadAsync(file);
          const readOne = async (names)=>{ for(const n of names){ const f=zip.file(new RegExp(n.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')+'$','i')); if(f && f.length){ return await f[0].async('text'); } } return null; };
          const orig   = await readOne(['feature_summary_original.csv','feature_summary.csv']);
          const pseudo = await readOne(['feature_summary_pseudo.csv']);
          const strat  = await readOne(['feature_statistics_with_strategy.csv']);
          const imp    = await readOne(['xai_feature_importance.csv','feature_importances.csv']);
          const risk   = await readOne(['integrated_risk_score.csv','integrated_risk.csv']);
          const got=[]; if(orig)got.push('feature_summary_original.csv'); if(pseudo)got.push('feature_summary_pseudo.csv'); if(strat)got.push('feature_statistics_with_strategy.csv'); if(imp)got.push('xai_feature_importance.csv'); if(risk)got.push('integrated_risk_score.csv');
          __zipSources = {orig,pseudo,strat,imp,risk};
          status.innerHTML = got.length? `Applied ${got.length} files from ZIP: ${got.join(', ')}` : '<span class="text-amber-700">No needed files in ZIP</span>';
          await loadAndRender();
        }catch(e){ console.error(e); status.textContent='ZIP handling failed'; }
      }
      (function setupZip(){
        const zone=document.getElementById('zipZone'); const input=document.getElementById('zipInput');
        zone?.addEventListener('click', ()=> input.click());
        zone?.addEventListener('dragover', (e)=>{ e.preventDefault(); zone.classList.add('dz-hl'); });
        zone?.addEventListener('dragleave', ()=> zone.classList.remove('dz-hl'));
        zone?.addEventListener('drop', (e)=>{ e.preventDefault(); zone.classList.remove('dz-hl'); const f=e.dataTransfer.files?.[0]; if(f) handleZipUpload(f); });
        input?.addEventListener('change', ()=>{ const f=input.files?.[0]; if(f) handleZipUpload(f); });
      })();

      autoLoadZipFromBridge();
    </script>
  </body>
</html>
