<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ANONYVIZ</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Momo+Trust+Display&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Momo Trust Display", sans-serif;
        background: #000;
        color: #fff;
      }

      .page {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        padding: 60px 20px 120px;
        gap: 36px;
      }

      .title {
        font-size: 1rem;
        letter-spacing: 0.4rem;
        color: #a5a1ff;
        font-weight: 700;
        margin-bottom: 10px;
      }

      .description {
        font-size: 1.05rem;
        line-height: 1.6;
        color: #dfdfdf;
        max-width: 520px;
        margin: 0 auto;
      }

      .hero-visual {
        width: 280px;
        max-width: 80vw;
        margin: 20px auto 26px;
        display: block;
        filter: drop-shadow(0 20px 35px rgba(84, 223, 252, 0.45));
      }

      .upload-btn {
        appearance: none;
        border: 2px solid rgba(255, 255, 255, 0.7);
        border-radius: 22px;
        padding: 14px 38px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        background: transparent;
        color: #fff;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.35),
          0 15px 28px rgba(0, 0, 0, 0.55);
        transition: transform 0.2s ease, box-shadow 0.2s ease,
          border-color 0.2s ease;
      }

      .upload-btn:hover {
        transform: translateY(-3px);
        border-color: #6ffbff;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.45),
          0 20px 36px rgba(0, 255, 255, 0.25);
      }

      .file-name {
        font-size: 0.95rem;
        color: #9de8ff;
        min-height: 1.4em;
        font-weight: 700;
      }

      .steps {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 36px;
        width: 100%;
        margin-top: 30px;
      }

      .dashboard {
        width: 100%;
        background: #000;
        border-radius: 32px;
        padding: 46px 32px 60px;
        display: none;
        flex-direction: column;
        gap: 46px;
        box-shadow: 0 40px 80px rgba(0, 0, 0, 0.65);
      }

      .dashboard.visible {
        display: flex;
      }

      .dashboard .steps {
        margin-top: 0;
      }

      .flow-panels {
        display: flex;
        flex-wrap: wrap;
        gap: 18px;
        align-items: stretch;
        justify-content: center;
        position: relative;
      }
      .download-pill{
        position:absolute;
        top:-3cm;
        left:50%;
        transform:translateX(-50%);
        z-index:5;
        pointer-events:auto;
      }
      .download-pill a{
        display:inline-flex;
        align-items:center;
        justify-content:center;
        padding:8px 18px;
        border-radius:999px;
        background:linear-gradient(90deg,#7c3aed 0%,#6ffbff 100%);
        color:#0b2240;
        font-weight:800;
        letter-spacing:0.01em;
        font-size:0.9rem;
        box-shadow:0 8px 16px rgba(0,0,0,0.25);
        text-decoration:none;
        cursor:pointer;
      }

      .flow-panel {
        flex: 1 1 280px;
        background: #fff;
        border-radius: 26px;
        padding: 28px 26px 32px 40px;
        color: #1b1b1b;
        min-width: 260px;
        box-shadow: 0 20px 32px rgba(0, 0, 0, 0.25);
        position: relative;
      }

      .flow-panel::before {
        content: "";
        position: absolute;
        left: 18px;
        top: 20px;
        bottom: 20px;
        width: 6px;
        border-radius: 999px;
        background: linear-gradient(180deg, #7c3aed, #a855f7);
      }

      .flow-panel h3 {
        margin: 0 0 20px;
        font-size: 1rem;
        font-weight: 700;
      }

      .flow-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .flow-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 12px 16px;
        border-radius: 20px;
        background: #f7f3ff;
        font-weight: 600;
        color: #2c1a34;
      }

      .flow-tag {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 999px;
        padding: 6px 16px;
        border: 1px solid #d7d0f7;
        font-size: 0.85rem;
        background: #fff;
        color: #51338c;
      }
      .flow-value {
        font-family: inherit;
        font-weight: 600;
        color: #51338c;
        letter-spacing: 0.01em;
      }

      .flow-row--strategy {
        flex-direction: column;
        align-items: stretch;
        gap: 0.4rem;
        background: #f5f5fb;
      }

      .flow-strategy-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        cursor: pointer;
      }

      .flow-strategy-arrow {
        width: 0;
        height: 0;
        border-left: 7px solid transparent;
        border-right: 7px solid transparent;
        border-top: 9px solid #9a8aca;
        transition: transform 0.2s ease;
        transform-origin: center;
      }

      .flow-row--strategy[aria-expanded="true"] .flow-strategy-arrow {
        transform: rotate(180deg);
      }

      .flow-strategy-body {
        display: none;
        font-size: 0.85rem;
        color: #5b4a88;
        line-height: 1.4;
      }

      .flow-row--strategy[aria-expanded="true"] .flow-strategy-body {
        display: block;
      }

      .flow-strategy-desc {
        margin: 0;
      }

      .flow-strategy-features {
        display: flex;
        flex-wrap: wrap;
        gap: 0.3rem;
        margin-top: 0.35rem;
      }

      .feature-chip {
        font-size: 0.75rem;
        font-weight: 500;
        color: #4c1d95;
        background: #fff;
        border-radius: 999px;
        padding: 0.2rem 0.65rem;
        border: 1px solid #e6d7ff;
      }

      .feature-chip--empty {
        opacity: 0.7;
        border-style: dashed;
        color: #6b617f;
      }

      .flow-row--combo {
        gap: 14px;
        align-items: flex-start;
      }

      .combo-badge {
        width: 28px;
        height: 28px;
        border-radius: 999px;
        background: #8b5cf6;
        color: #fff;
        font-size: 0.85rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .combo-body {
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 100%;
      }

      .combo-chips {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .combo-chip {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 999px;
        padding: 6px 12px;
        border: 1px solid #d7d0f7;
        background: #fff;
        color: #4c1d95;
        font-weight: 700;
        font-size: 0.9rem;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.45);
      }

      .combo-chip--empty {
        border-style: dashed;
        opacity: 0.7;
      }

      .flow-arrow {
        width: 140px;
        min-height: 140px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .flow-arrow-line {
        width: 110px;
        height: 6px;
        border-radius: 999px;
        background: linear-gradient(90deg, #fff0ff 0%, #f0d9ff 50%, #ead8ff 100%);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.85),
          0 12px 30px rgba(0, 0, 0, 0.45);
      }

      .flow-arrow-pointer {
        position: absolute;
        top: 50%;
        left: 51%;
        width: 36px;
        height: 32px;
        transform: translate(-20%, -50%);
        background: linear-gradient(135deg, #7c3aed, #c084fc);
        clip-path: polygon(0% 50%, 0% 0%, 100% 50%, 0% 100%);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.45);
      }


      .step-card {
        width: 200px;
        background: #fff;
        border-radius: 22px;
        padding: 26px 20px 32px;
        color: #151515;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 14px;
        position: relative;
        border: 3px solid transparent;
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.45);
        transition: border-color 0.25s ease, box-shadow 0.25s ease;
      }
      .step-card[data-link] {
        cursor: pointer;
      }

      .step-card img {
        width: 98px;
        height: auto;
      }

      .step-card strong {
        font-size: 1.02rem;
      }

      .step-card button {
        width: 100%;
        background: #030303;
        color: #fff;
        border: none;
        border-radius: 12px;
        padding: 12px 0;
        font-size: 0.95rem;
        cursor: pointer;
        font-weight: 600;
      }

      .step-card:hover {
        border-color: #6ffbff;
        animation: neonPulse 1.4s ease-in-out infinite alternate;
      }

      .hover-note {
        position: absolute;
        top: -48px;
        left: 50%;
        transform: translate(-50%, 5px);
        padding: 10px 18px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.88);
        color: #fff;
        font-size: 0.82rem;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      .step-card.tip:hover .hover-note {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      @keyframes neonPulse {
        from {
          box-shadow: 0 16px 30px rgba(0, 0, 0, 0.45),
            0 0 12px rgba(84, 223, 252, 0.45);
        }
        to {
          box-shadow: 0 16px 30px rgba(0, 0, 0, 0.45),
            0 0 42px rgba(84, 223, 252, 1);
        }
      }

      @media (max-width: 900px) {
        .flow-arrow {
          display: none;
        }
        .flow-panel {
          min-width: 100%;
        }
      }

      @media (max-width: 640px) {
        .title {
          letter-spacing: 0.3rem;
        }

        .step-card {
          width: 80%;
          max-width: 320px;
        }
      }
    </style>
  </head>
  <body>
    <main class="page">
      <div>
        <div class="title">ANONYVIZ</div>
        <p class="description">
          ?∞Ïù¥?∞ÏÖã Í∞ÄÎ™ÖÏ≤òÎ¶¨Î? ?ÑÌïú ÏµúÏ†Å '?ÑÍ≥ÑÍ∞???Ï∂îÏ∂ú?òÍ≥†,<br />
          Í∞Ä???àÏ†Ñ???∞Ïù¥??'Ï°∞Ìï©'???úÍ≥µ?òÎäî ?åÎû´??
        </p>
      </div>

      <img src="1.png" alt="Anonyviz Ïª§Î≤Ñ ?ºÎü¨?§Ìä∏" class="hero-visual" />

      <input
        type="file"
        id="dataUpload"
        accept=".zip,application/zip"
        style="display: none"
      />
      <button class="upload-btn" id="uploadTrigger">?∞Ïù¥???ÖÎ°ú?úÌïòÍ∏?/button>
      <div class="file-name" id="fileName" aria-live="polite"></div>

      <section id="dashboard" class="dashboard" aria-hidden="true">
        <div class="flow-panels">
          <article class="flow-panel">
            <h3>Í∞??ÅÌô©Î≥?Ï∂îÏ≤ú ?ÑÍ≥ÑÍ∞?Percentile)</h3>
            <ul class="flow-list">
              <li class="flow-row">
                <span class="flow-tag">Î≥¥Ïàò??/span>
                <span class="flow-value" data-tier="conservative">P-- (--)</span>
              </li>
              <li class="flow-row">
                <span class="flow-tag">Í∑†Ìòï??/span>
                <span class="flow-value" data-tier="balanced">P-- (--)</span>
              </li>
              <li class="flow-row">
                <span class="flow-tag">?êÏ??∞ÏÑ†??/span>
                <span class="flow-value" data-tier="riskfirst">P-- (--)</span>
              </li>
            </ul>
          </article>
          <div class="flow-arrow" aria-hidden="true">
            <span class="flow-arrow-line"></span>
            <span class="flow-arrow-pointer"></span>
          </div>
          <div class="download-pill">
            <a href="#" id="reportDownloadBtn">REPORT DOWNLOAD</a>
          </div>
          <article class="flow-panel">
            <h3>Í∞??πÏÑ±Î≥?Í∞ÄÎ™ÖÏ≤òÎ¶??ÑÎûµ Ï∂îÏ≤ú</h3>
            <ul class="flow-list">
              <li class="flow-row flow-row--strategy" aria-expanded="false">
                <div class="flow-strategy-head" role="button" tabindex="0">
                  <span>Density-based</span>
                  <span class="flow-strategy-arrow"></span>
                </div>
                <div class="flow-strategy-body">
                  <p class="flow-strategy-desc">?∞Ïù¥??Î∂ÑÌè¨???∞Îùº Íµ¨Í∞Ñ???êÎèô Ï°∞Ï†ï??ÎØºÍ∞ê ?ÅÏó≠??Î∂Ä?úÎüΩÍ≤?Ï≤òÎ¶¨?©Îãà??</p>
                  <div class="flow-strategy-features" data-strategy-list="Density-based"></div>
                </div>
              </li>
              <li class="flow-row flow-row--strategy" aria-expanded="false">
                <div class="flow-strategy-head" role="button" tabindex="0">
                  <span>Log binning</span>
                  <span class="flow-strategy-arrow"></span>
                </div>
                <div class="flow-strategy-body">
                  <p class="flow-strategy-desc">Î°úÍ∑∏ ?§Ï???Íµ¨Í∞Ñ?îÎ? ?µÌï¥ Íº¨Î¶¨ Î∞©Ï?Î•?Í∞ïÌôî?òÎäî ?ÑÎûµ?ÖÎãà??</p>
                  <div class="flow-strategy-features" data-strategy-list="Log binning"></div>
                </div>
              </li>
              <li class="flow-row flow-row--strategy" aria-expanded="false">
                <div class="flow-strategy-head" role="button" tabindex="0">
                  <span>KMeans</span>
                  <span class="flow-strategy-arrow"></span>
                </div>
                <div class="flow-strategy-body">
                  <p class="flow-strategy-desc">?¥Îü¨?§ÌÑ∞Î≥ÑÎ°ú ?úÎ°ú ?§Î•∏ ?ÑÍ≥ÑÍ∞íÏùÑ ?ÅÏö©??Í∑†Ìòï??Ï∞æÏäµ?àÎã§.</p>
                  <div class="flow-strategy-features" data-strategy-list="KMeans"></div>
                </div>
              </li>
              <li class="flow-row flow-row--strategy" aria-expanded="false">
                <div class="flow-strategy-head" role="button" tabindex="0">
                  <span>Decision Tree</span>
                  <span class="flow-strategy-arrow"></span>
                </div>
                <div class="flow-strategy-body">
                  <p class="flow-strategy-desc">Í∑úÏπô Í∏∞Î∞ò Î∂ÑÌï†Î°?ÎØºÍ∞ê Íµ¨Í∞Ñ??Î™ÖÏãú?ÅÏúºÎ°??úÏñ¥?òÎäî Í≥†Ï†ï ?ÑÎûµ?ÖÎãà??</p>
                  <div class="flow-strategy-features" data-strategy-list="Decision Tree"></div>
                </div>
              </li>
            </ul>
          </article>
          <div class="flow-arrow" aria-hidden="true">
            <span class="flow-arrow-line"></span>
            <span class="flow-arrow-pointer"></span>
          </div>
          <article class="flow-panel">
            <h3>?àÏ†Ñ??Ï°∞Ìï© Ï∂îÏ≤ú</h3>
            <ul class="flow-list">
              <li
                class="flow-row flow-row--combo"
                data-combo-rank="1"
                data-combo-strategy="Density-based"
              >
                <span class="combo-badge">1</span>
                <div class="combo-body">
                  <div class="combo-chips" data-combo-features></div>
                </div>
              </li>
              <li
                class="flow-row flow-row--combo"
                data-combo-rank="2"
                data-combo-strategy="Log binning"
              >
                <span class="combo-badge">2</span>
                <div class="combo-body">
                  <div class="combo-chips" data-combo-features></div>
                </div>
              </li>
            </ul>
          </article>
        </div>

        <div class="steps">
          <article class="step-card tip" data-link="thre.html">
            <span class="hover-note">Í∞ÄÎ™ÖÏ≤òÎ¶?Î∞©Î≤ï Ï§?Íµ¨Í∞Ñ?îÏóê??ÏµúÏ†Å???ÑÍ≥ÑÍ∞íÏùÑ ?ÑÏ∂ú?¥Î¥Ö?àÎã§.</span>
            <strong>?ÑÍ≥ÑÍ∞?Î∂ÑÏÑù</strong>
            <img src="thre.png" alt="??? ?? ????" />
            <button>?†ÌÉù</button>
          </article>
          <article class="step-card tip" data-link="stra.html">
            <span class="hover-note">?ÑÍ≥ÑÍ∞?Í∏∞Î∞ò?ºÎ°ú Í∞???™©Î≥ÑÎ°ú Í∞ÄÎ™ÖÏ≤òÎ¶??ÑÎûµ??Ï∂îÏ≤ú?¥ÎìúÎ¶ΩÎãà??</span>
            <strong>Í∞ÄÎ™ÖÏ≤òÎ¶??ÑÎûµ Ï∂îÏ≤ú</strong>
            <img src="strategy.png" alt="???? ?? ?? ????" />
            <button>?†ÌÉù</button>
          </article>
          <article class="step-card tip" data-link="new.html">
            <span class="hover-note">Í∞ÄÎ™ÖÏ≤òÎ¶??∞Ïù¥??Í∏∞Î∞ò?ºÎ°ú ?àÏ†Ñ??Ï°∞Ìï©???ÑÏ∂ú?©Îãà??</span>
            <strong>?àÏ†Ñ??Ï°∞Ìï© ?ÑÏ∂ú</strong>
            <img src="coop.png" alt="??/?? ?? ????" />
            <button>?†ÌÉù</button>
          </article>
        </div>
      </section>
    </main>

            <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>
    <script src="zip-bridge.js"></script>
    <script>
      (function () {
        const uploadTrigger = document.getElementById("uploadTrigger");
        const dataUpload = document.getElementById("dataUpload");
        const fileName = document.getElementById("fileName");
        const dashboard = document.getElementById("dashboard");
        const tierValueEls = {
          conservative: document.querySelector('[data-tier="conservative"]'),
          balanced: document.querySelector('[data-tier="balanced"]'),
          riskfirst: document.querySelector('[data-tier="riskfirst"]'),
        };
        const strategyListEls = {};
        document.querySelectorAll("[data-strategy-list]").forEach((el) => {
          strategyListEls[el.dataset.strategyList.toLowerCase()] = el;
        });
        const comboEls = Array.from(document.querySelectorAll("[data-combo-rank]"));
        let latestZipSave = null;
        const downloadBtn = document.getElementById("reportDownloadBtn");

        const fallbackTier = "P-- (--)";
        const fallbackFeature =
          '<span class="feature-chip feature-chip--empty">?∞Ïù¥???ÜÏùå</span>';

        const normalizeKey = (v) => String(v || "").toLowerCase().replace(/[\s_]+/g, "");
        const fallbackCombo = "???";

        function setTierValues(values) {
          ["conservative", "balanced", "riskfirst"].forEach((type) => {
            const el = tierValueEls[type];
            if (el) el.textContent = values?.[type] ?? fallbackTier;
          });
        }

        function setStrategyFeatures(map) {
          Object.entries(strategyListEls).forEach(([key, el]) => {
            if (!el) return;
            const feats = map?.[key] ?? [];
            el.innerHTML = feats.length
              ? feats.map((f) => `<span class="feature-chip">${f}</span>`).join("")
              : fallbackFeature;
          });
        }

        function renderComboRow(el, features) {
          const chipsEl = el.querySelector("[data-combo-features]");
          const hasFeatures = Array.isArray(features) && features.length > 0;
          const feats = hasFeatures ? features : [fallbackCombo];
          if (chipsEl) {
            chipsEl.innerHTML = feats
              .map(
                (f) =>
                  `<span class="combo-chip${hasFeatures ? "" : " combo-chip--empty"}">${f}</span>`
              )
              .join("");
          }
        }

        function setRecommendedCombos(list) {
          comboEls.forEach((el) => {
            const rank = Number(el.dataset.comboRank) || 0;
            const raw = list && list[rank - 1] ? list[rank - 1] : null;
            const features = raw
              ? String(raw)
                  .split("+")
                  .map((t) => t.trim())
                  .filter(Boolean)
              : [];
            renderComboRow(el, features);
          });
        }

        function findEntry(zip, filename) {
          const escaped = filename.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const regex = new RegExp(`${escaped}$`, "i");
          const matches = zip.file(regex);
          return matches && matches.length ? matches[0] : null;
        }

        function parseCSV(text) {
          if (!text) return { header: [], rows: [] };
          const first = text.split(/\r?\n/)[0] || "";
          const cands = [",", ";", "\t"];
          let delim = ",";
          let best = -1;
          cands.forEach((d) => {
            const c = (first.match(new RegExp(`\\${d}`, "g")) || []).length;
            if (c > best) {
              best = c;
              delim = d;
            }
          });
          const rows = [];
          let row = [];
          let field = "";
          let inQuotes = false;
          for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            if (inQuotes) {
              if (ch === '"') {
                if (text[i + 1] === '"') {
                  field += '"';
                  i++;
                } else {
                  inQuotes = false;
                }
              } else {
                field += ch;
              }
            } else if (ch === '"') {
              inQuotes = true;
            } else if (ch === delim) {
              row.push(field);
              field = "";
            } else if (ch === "\r") {
              continue;
            } else if (ch === "\n") {
              row.push(field);
              rows.push(row);
              row = [];
              field = "";
            } else {
              field += ch;
            }
          }
          row.push(field);
          if (row.length > 1 || row[0] !== "") rows.push(row);
          if (!rows.length) return { header: [], rows: [] };
          const header = rows.shift().map((h) => String(h || "").trim());
          const data = rows
            .filter((r) => r.some((cell) => String(cell || "").trim() !== ""))
            .map((r) => {
              const obj = {};
              header.forEach((h, idx) => (obj[h] = (r[idx] ?? "").trim()));
              return obj;
            });
          return { header, rows: data };
        }

        async function parseTierData(zip) {
          const entry = findEntry(zip, "recommendation_cards.json");
          if (!entry) return null;
          const json = JSON.parse(await entry.async("string"));
          const out = {};
          (Array.isArray(json) ? json : []).forEach((row) => {
            const typeRaw = row?.type;
            if (!typeRaw) return;
            const key = typeRaw === "recall_first" ? "riskfirst" : typeRaw;
            if (!["conservative", "balanced", "riskfirst"].includes(key)) return;
            const pct = row?.percentile ?? "--";
            const thr = row?.threshold;
            const thrVal = Number.isFinite(+thr) ? (+thr).toFixed(2) : "--";
            out[key] = `P${pct} (${thrVal})`;
          });
          return out;
        }

        function canonicalStrategyName(value) {
          if (!value) return null;
          const lower = value.toLowerCase();
          if (/density/.test(lower)) return "density-based";
          if (/log/.test(lower) && /bin/.test(lower)) return "log binning";
          if (/k[-\s]?means?/.test(lower)) return "kmeans";
          if (/decision/.test(lower) || /tree/.test(lower)) return "decision tree";
          return null;
        }

        async function parseStrategyData(zip) {
          const stratEntry = findEntry(
            zip,
            "feature_statistics_with_strategy.csv"
          );
          const awEntry = findEntry(zip, "aw_fb_data.csv");
          if (!stratEntry && !awEntry) return null;

          // Parse strategy CSV if present (to get recommended_strategy order)
          let stratRows = [];
          if (stratEntry) {
            const parsed = parseCSV(await stratEntry.async("string"));
            const headers = parsed.header.map((h) => normalizeKey(h));
            const stratIdx = headers.findIndex((k) =>
              [
                "recommendedstrategy",
                "recommended_strategy",
                "strategy",
                "beststrategy",
                "best_strategy",
              ].includes(k)
            );
            if (stratIdx >= 0) {
              const stratCol = parsed.header[stratIdx];
              stratRows = parsed.rows
                .map((r) => canonicalStrategyName(r[stratCol]))
                .filter(Boolean);
            }
          }

          // Parse aw_fb_data header as feature list (column order)
          let awFeatures = [];
          if (awEntry) {
            const parsedAw = parseCSV(await awEntry.async("string"));
            const rawHeaders = parsedAw.header;
            awFeatures = rawHeaders.filter((h, idx) => {
              const norm = normalizeKey(h);
              if (!norm) return false;
              if (/^[0-9]+$/.test(norm)) return false; // skip index-like columns
              // first column often an index; drop if no letters
              if (idx === 0 && !/[a-z]/i.test(norm)) return false;
              return true;
            });
          }

          const groups = {};

          // If we have both strategy order and aw header, map by index
          if (stratRows.length && awFeatures.length) {
            const len = Math.min(stratRows.length, awFeatures.length);
            for (let i = 0; i < len; i++) {
              const strat = stratRows[i];
              const feat = awFeatures[i];
              if (!strat || !feat) continue;
              const key = strat.toLowerCase();
              if (!groups[key]) groups[key] = [];
              groups[key].push(feat);
            }
            return groups;
          }

          // Fallback: use strategy CSV feature column (legacy)
          if (stratEntry) {
            const parsed = parseCSV(await stratEntry.async("string"));
            const headers = parsed.header.map((h) => normalizeKey(h));
            const featIdx = headers.findIndex((k) =>
              ["feature", "featurename", "name", "column"].includes(k)
            );
            const stratIdx = headers.findIndex((k) =>
              [
                "recommendedstrategy",
                "recommended_strategy",
                "strategy",
                "beststrategy",
                "best_strategy",
              ].includes(k)
            );
            if (featIdx >= 0 && stratIdx >= 0) {
              const featCol = parsed.header[featIdx];
              const stratCol = parsed.header[stratIdx];
              parsed.rows.forEach((row) => {
                const feat = row[featCol]?.trim();
                const strat = canonicalStrategyName(row[stratCol]);
                if (!feat || !strat) return;
                const key = strat.toLowerCase();
                if (!groups[key]) groups[key] = [];
                groups[key].push(feat);
              });
            }
          }

          return Object.keys(groups).length ? groups : null;
        }

        function pickTopCombosFromParsed(parsed) {
          if (!parsed || !Array.isArray(parsed.header) || !Array.isArray(parsed.rows))
            return null;
          const headersNorm = parsed.header.map((h) => normalizeKey(h));
          const featKey = normalizeKey("feature_combination");
          const featIdx = headersNorm.indexOf(featKey);
          if (featIdx < 0) return null;

          const diffKeys = [
            "loglik_drop_vs_originalcombo",
            "loglik_drop_vs_original_combo",
            "loglik_drop_vs_original",
          ];
          let scoreIdx = diffKeys
            .map((key) => headersNorm.indexOf(normalizeKey(key)))
            .find((idx) => idx >= 0);
          if (scoreIdx === undefined || scoreIdx === -1) {
            scoreIdx = headersNorm.findIndex((k, idx) => {
              if (idx === featIdx) return false;
              return parsed.rows.some((row) =>
                Number.isFinite(parseFloat(row[parsed.header[idx]]))
              );
            });
          }

          const combos = parsed.rows
            .map((row, idx) => {
              const name = row[parsed.header[featIdx]]?.trim();
              const scoreRaw = scoreIdx >= 0 ? row[parsed.header[scoreIdx]] : null;
              const score = Number.isFinite(parseFloat(scoreRaw))
                ? parseFloat(scoreRaw)
                : NaN;
              return { name, score, idx };
            })
            .filter((item) => item.name);

          const sorted = combos.sort((a, b) => {
            const aHas = Number.isFinite(a.score);
            const bHas = Number.isFinite(b.score);
            if (aHas && bHas) {
              if (a.score === b.score) return a.idx - b.idx;
              return a.score - b.score; // asc
            }
            if (aHas) return -1;
            if (bHas) return 1;
            return a.idx - b.idx;
          });

          return sorted.slice(0, 2).map((c) => c.name);
        }

        // Pick top feature combinations (ascending) from the combinations CSV inside the ZIP.
        async function parseCombinationResults(zip) {
          const candidates = ["combinations_compare.csv", "global.csv", "integrated.csv"];
          let entry = null;
          for (const name of candidates) {
            const found = findEntry(zip, name);
            if (found) {
              entry = found;
              break;
            }
          }
          if (!entry) return null;

          const parsed = parseCSV(await entry.async("string"));
          return pickTopCombosFromParsed(parsed);
        }

        // Load combos from a local CSV (fallback when ZIP???ÜÎäî Í≤ΩÏö∞)
        async function loadDefaultCombinationFile() {
          try {
            const resp = await fetch("global.csv", { cache: "no-cache" });
            if (!resp.ok) return;
            const text = await resp.text();
            const combos = pickTopCombosFromParsed(parseCSV(text));
            if (!combos || !combos.length) return;
            const alreadySet = comboEls.some(
              (el) => el.textContent && !el.textContent.includes(fallbackCombo)
            );
            if (alreadySet) return;
            setRecommendedCombos(combos);
            if (fileName) fileName.textContent = "Í∏∞Î≥∏ global.csv Î°úÎìú??;
            showDashboard();
          } catch (err) {
            console.warn("Í∏∞Î≥∏ global.csv Î°úÎìú ?§Ìå®", err);
          }
        }

        async function processZip(file) {
          if (!file || !window.JSZip) {
            setTierValues();
            setStrategyFeatures();
            setRecommendedCombos();
            return;
          }
          try {
            const zip = await JSZip.loadAsync(file);
            const [tiers, strategies, combos] = await Promise.all([
              parseTierData(zip),
              parseStrategyData(zip),
              parseCombinationResults(zip),
            ]);
            setTierValues(tiers);
            setStrategyFeatures(strategies);
            setRecommendedCombos(combos);
          } catch (err) {
            console.warn("ZIP Î∂ÑÏÑù ?§Ìå®", err);
            setTierValues();
            setStrategyFeatures();
            setRecommendedCombos();
          }
        }

        const hideDashboard = () => {
          dashboard?.classList.remove("visible");
          dashboard?.setAttribute("aria-hidden", "true");
        };

        const showDashboard = () => {
          if (!dashboard) return;
          dashboard.classList.add("visible");
          dashboard.setAttribute("aria-hidden", "false");
          dashboard.scrollIntoView({ behavior: "smooth", block: "start" });
        };

        uploadTrigger.addEventListener("click", () => {
          dataUpload.value = "";
          fileName.textContent = "";
          hideDashboard();
          dataUpload.click();
        });

        dataUpload.addEventListener("change", () => {
          const [file] = dataUpload.files;
          if (!file) return;
          if (!file.name.toLowerCase().endsWith(".zip")) {
            alert("ZIP ?åÏùºÎß??ÖÎ°ú?úÌï† ???àÏäµ?àÎã§.");
            dataUpload.value = "";
          fileName.textContent = "";
            hideDashboard();
            ZipBridge.clear().catch(() => {});
            latestZipSave = null;
            setTierValues();
            setStrategyFeatures();
            setRecommendedCombos();
            return;
          }
          fileName.textContent = `${file.name}`;
          showDashboard();
          latestZipSave = ZipBridge.save(file);
          latestZipSave.catch((err) => console.warn("ZIP ?Ä???§Ìå®", err));
          processZip(file);
        });

        document.querySelectorAll(".step-card[data-link]").forEach((card) => {
          const navigate = async () => {
            if (latestZipSave) {
              try {
                await latestZipSave;
              } catch (err) {
                console.warn("ZIP ?Ä???ÄÍ∏?Ï§??§Î•ò", err);
              }
            }
            window.location.href = card.dataset.link;
          };
          card.addEventListener("click", async (e) => {
            if (!e.target.closest("button")) await navigate();
          });
          card.querySelector("button")?.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            await navigate();
          });
        });

        (async function tryRestoreZip() {
          if (!window.ZipBridge) return;
          try {
            const stored = await ZipBridge.load();
            if (!stored?.blob) return;
            const restoredFile = new File([stored.blob], stored.name || "bundle.zip", {
              type: "application/zip",
              lastModified: stored.lastModified || Date.now(),
            });
            const dt = new DataTransfer();
            dt.items.add(restoredFile);
            dataUpload.files = dt.files;
            fileName.textContent = `${restoredFile.name}`;
            showDashboard();
            latestZipSave = Promise.resolve(stored);
            processZip(restoredFile);
          } catch (err) {
            console.warn("ZIP ?ÅÌÉú Î≥µÏõê ?§Ìå®", err);
          }
        })();

        loadDefaultCombinationFile();

        document.querySelectorAll(".flow-row--strategy").forEach((row) => {
          const head = row.querySelector(".flow-strategy-head");
          const toggle = () => {
            const expanded = row.getAttribute("aria-expanded") === "true";
            row.setAttribute("aria-expanded", expanded ? "false" : "true");
          };
          head?.addEventListener("click", toggle);
          head?.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              toggle();
            }
          });
        });

        function extractTierRows() {
          const policyMap = [
            { label: "Î≥¥Ïàò??, key: "conservative", purpose: "?§ÌÉê ÏµúÏÜå?? ?∞Ïù¥???úÏö©???ïÎ?" },
            { label: "Í∑†Ìòï??, key: "balanced", purpose: "?ïÎ??Ñ¬∑Ïû¨?ÑÏú® Í∑†Ìòï" },
            { label: "?êÏ??∞ÏÑ†??, key: "riskfirst", purpose: "?ÑÎùº?¥Î≤Ñ??Î≥¥Ìò∏ ?ïÎ?" },
          ];
          return policyMap.map((item) => {
            const value = tierValueEls[item.key]?.textContent?.trim() || fallbackTier;
            return [item.label, value, item.purpose];
          });
        }

        function extractStrategyRows() {
          return Array.from(document.querySelectorAll(".flow-row--strategy")).map((row) => {
            const name = row.querySelector(".flow-strategy-head span")?.textContent?.trim() || "-";
            const chips = Array.from(
              row.querySelectorAll(".flow-strategy-features .feature-chip")
            ).map((c) => c.textContent.trim());
            const featureText = chips.length
              ? chips.join(", ")
              : (row.querySelector(".flow-strategy-features")?.textContent || "-").trim();
            return [name, featureText || "-"];
          });
        }

        function extractComboRows() {
          return comboEls
            .map((el) => {
              const rank = el.dataset.comboRank || "";
              const chips = Array.from(el.querySelectorAll(".combo-chip")).map((c) =>
                c.textContent.trim()
              );
              const comboText = chips.length ? chips.join(", ") : fallbackCombo;
              return [rank, comboText];
            })
            .sort((a, b) => Number(a[0]) - Number(b[0]));
        }

        function generateReportPdf() {
          if (!window.jspdf || !window.jspdf.jsPDF || !window.jspdf.jsPDF.API.autoTable) {
            alert("PDF ?ºÏù¥Î∏åÎü¨Î¶¨Î? Î∂àÎü¨?§Ï? Î™ªÌñà?µÎãà?? ?†Ïãú ???§Ïãú ?úÎèÑ?¥Ï£º?∏Ïöî.");
            return;
          }

          const doc = new window.jspdf.jsPDF({ unit: "pt", format: "a4" });

          const tierRows = extractTierRows();
          doc.setFontSize(16);
          doc.text("?ÅÌô©Î≥??ïÏ±Ö ?§Î™Ö??, 40, 50);
          doc.autoTable({
            startY: 70,
            head: [["?ïÏ±Ö ?†Ìòï", "Percentile/?ÑÍ≥ÑÍ∞?, "Î™©Ï†Å"]],
            body: tierRows,
            styles: { fontSize: 11, cellPadding: 8 },
            headStyles: { fillColor: [230, 230, 230], textColor: [40, 40, 40] },
          });

          doc.addPage();
          const strategyRows = extractStrategyRows();
          doc.text("Í∞ÄÎ™ÖÏ≤òÎ¶??ÑÎûµÎ≥??ÅÏö© Î≥Ä??Î™©Î°ù", 40, 50);
          doc.autoTable({
            startY: 70,
            head: [["Í∞ÄÎ™ÖÏ≤òÎ¶??ÑÎûµ", "?ÅÏö© Î≥Ä??Î™©Î°ù"]],
            body: strategyRows,
            styles: { fontSize: 11, cellPadding: 8 },
            headStyles: { fillColor: [230, 230, 230], textColor: [40, 40, 40] },
            columnStyles: { 0: { fontStyle: "bold" } },
          });

          doc.addPage();
          const comboRows = extractComboRows();
          doc.text("Ï∂îÏ≤ú Ï°∞Ìï© ??™©", 40, 50);
          doc.autoTable({
            startY: 70,
            head: [["?úÏúÑ", "Ï°∞Ìï©???¨Ìï®????™©"]],
            body: comboRows,
            styles: { fontSize: 11, cellPadding: 8 },
            headStyles: { fillColor: [230, 230, 230], textColor: [40, 40, 40] },
            columnStyles: { 0: { fontStyle: "bold" } },
          });

          doc.save("anonyviz-report.pdf");
        }

        downloadBtn?.addEventListener("click", (e) => {
          e.preventDefault();
          generateReportPdf();
        });
      })();
    </script>

  </body>
</html>
